# Copyright (c) HashiCorp, Inc.
# SPDX-License-Identifier: MPL-2.0

# Default values for Terraform Enterprise on Kubernetes.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

replicaCount: 1

image:
  repository: nginx
  pullPolicy: IfNotPresent
  # Overrides the image tag whose default is the chart appVersion.
  tag: ""

# Image pull secret to use for registry authentication.
## FDO image pull 시 로그인 시크릿 정보 없으면 인가를 받지를 못함
imagePullSecrets:
- name: terraform-enterprise

# Image sets the repo, name and tag of the Terraform Enterprise image to use.
image:
  repository: images.releases.hashicorp.com
  name: hashicorp/terraform-enterprise
  tag: v202311-1

serviceAccount:
  annotations: {}

pod:
  # Configure pod annotations
  annotations: {}
container:
  # Configure pod specific security context settings
  securityContext: {}

# Resource limits are not set by default, to give the user the ability to set specific resource limits.
# If you do want to specify resource limits, uncomment the following lines and adjust them as necessary.
resources:
  requests:
    memory: "250Mi"
    cpu: "750m"
    # limits:
    #   memory: ""
    #   cpu: ""

# TLS for end-to-end encrypted transport
tls:
  certificateSecret: terraform-enterprise-certificates
  caCertBaseDir: /etc/ssl/certs
  caCertFileName: custom_ca_certs.pem
  certMountPath: /etc/ssl/private/terraform-enterprise/cert.pem
  keyMountPath: /etc/ssl/private/terraform-enterprise/key.pem
  # certData:
  # keyData:
  # caCertData:

tfe:
  metrics:
    enable: true
    httpPort: 9090
    httpsPort: 9091
  privateHttpPort: 8080
  privateHttpsPort: 8443

# nodeSelector labels for server pod assignment, formatted as a multi-line string or YAML map.
nodeSelector: {}

# Toleration Settings
# This should be either a multi-line string or YAML matching
# the Toleration array in a PodSpec.
tolerations: []
# tolerations:
# - key: "key"
#   operator: "Equal"
#   value: "value"
#   effect: "NoSchedule"

# Affinity Settings
# Commenting out or setting as empty the affinity variable, will allow
# deployment to single node services such as Minikube
# This should be either a multi-line string or YAML matching the PodSpec's affinity field.
affinity: {}
#
## Example:
#
#  affinity: |
#    podAntiAffinity:
#      requiredDuringSchedulingIgnoredDuringExecution:
#        - labelSelector:
#            matchExpressions:
#             - key: foo
#               operator: In
#               values:
#               - bar
#          topologyKey: "kubernetes.io/hostname
#    podAffinity:
#      preferredDuringSchedulingIgnoredDuringExecution:
#        - weight: 50
#        podAffinityTerm:
#          labelSelector:
#            matchExpressions:
#            - key: foo
#              operator: In
#              values:
#                - bar
#          topologyKey: "kubernetes.io/hostname"

# Security context for the deployment template.
# The deployment securityContext is not set by default.
#This should be a YAML map corresponding to a
# Kubernetes [SecurityContext](https://kubernetes.io/docs/tasks/configure-pod-container/security-context/) object.
securityContext: {}
# runAsNonRoot: false
# runAsUser: 1000
# runAsGroup: 3000
# fsGroup: 2000

# InitContainers is a list of init containers. Specified as a YAML list.
# This is useful if you need to run a script to provision TLS certificates or
# write out configuration files in a dynamic way.
initContainers: null
## Example ##
#- name: init-demo
#  image: busybox
#  command:
#      - wget
#      - "-O"
#      - "/work-dir/index.html"
#      - http://info.cern.ch
#    args:
#  volumeMounts:
#  - name: workdir
#      mountPath "/work-dir"
#    dnsPolicy: Default
#    volumes:
#    - name: workdir
#    emptyDir: {}

# Ingress allows ingress services to be created to allow external access
# from Kubernetes to access Terraform Enterprise pods.
# ALB 사용 시 사용
ingress:
  enabled: false
  className: "" # nginx
  annotations: {}
  # nginx.ingress.kubernetes.io/backend-protocol: "HTTPS"
  hosts:
  - host: "" # "*.ptfe-dev.aws.ptfedev.com"
    paths:
    - path: /
      pathType: Prefix
      serviceName: "terraform-enterprise"
      portNumber: 443
  tls: []
  # - secretName: terraform-enterprise-certificates
  #   hosts:
  #   - "*.ptfe-dev.aws.ptfedev.com"

# Injector service specific configurations
service:
  annotations:
    'service.beta.kubernetes.io/aws-load-balancer-subnets': "[외부 통신 서브넷]"
    ## nlb 외부 통신
    'service.beta.kubernetes.io/aws-load-balancer-scheme': "internet-facing"
    ## target group 지정 type
    'service.beta.kubernetes.io/aws-load-balancer-nlb-target-type': "instance"
    ## 인증서 arn
    'service.beta.kubernetes.io/aws-load-balancer-ssl-cert': "[인증서 arn]"
    ## nlb 프로토콜 annotation
    'service.beta.kubernetes.io/aws-load-balancer-backend-protocol': 'ssl'
  type: LoadBalancer # ClusterIP
  port: 443
  nodePort: 32443
  loadBalancerClass: service.k8s.aws/nlb

env:
  variables:
    ## terraform 접근 URL 
    TFE_HOSTNAME: [terraform 접근 URL] ## ex) rlarlqja1001.rlarlqja1001.xyz Protocol 없이 설정

    ## container로 올리는 postgresql svc dns, headless로 설정 시 접근이 안되는 문제로 postgres 기본 svc로 설정
    ## [helm 배포 시 설정 된 이름].[namespace].svc.cluster.local ==> 포트 지정 없이 설정
    TFE_DATABASE_HOST: "postgresql-dev.default.svc.cluster.local"

    ## container로 올리는 postgresql database 이름
    ## postgre value.yaml 135 번째 줄 설정
    TFE_DATABASE_NAME: "[TFE_DATABASE_NAME]"
    ## ssl mode
    TFE_DATABASE_PARAMETERS: "sslmode=disable"

    ## container로 올리는 postgresql 유저 계정
    ## postgre value.yaml 129 번째 줄 설정
    TFE_DATABASE_USER: "[TFE_DATABASE_USER]"

    ## container로 올리는 redis dns, headless로 설정하면 접근이 안되는 문제로 master로 설정
    ## [helm 배포 시 설정 된 이름].[namespace].svc.cluster.local:6379
    TFE_REDIS_HOST: "redis-dev-master.redis.svc.cluster.local:6379"

    ## redis AUTH 사용할 경우 에러 발생으로 임시 false
    ## auth 기능 비활성 시 redis value.yaml 123 번째 줄 기능 false 설정
    TFE_REDIS_USE_AUTH: "false"

    ## container로 올리는 minio type은 s3로 해야함
    TFE_OBJECT_STORAGE_TYPE: s3

    ## container로 올리는 minio bucket 이름
    TFE_OBJECT_STORAGE_S3_BUCKET: "[minio bucket name]"

    ## container로 올리는 minio svc dns
    ## [helm 배포 시 설정 된 이름].[namespace].svc.cluster.local:9000
    TFE_OBJECT_STORAGE_S3_ENDPOINT: "http://minio-dev.minio.svc.cluster.local:9000"

    ## container로 올리는 minio가 올라가는 aws 지역
    TFE_OBJECT_STORAGE_S3_REGION: "ap-northeast-2"

    TFE_IACT_SUBNETS: "0.0.0.0/0"
    TFE_CAPACITY_CONCURRENCY: 10

    ## container로 올리는 minio 접근 시 admin 계정 ID,Password
    ## minio vaule.yaml 90 번째 줄 설정
    TFE_OBJECT_STORAGE_S3_ACCESS_KEY_ID: "[admin 계정 ID]"
    TFE_OBJECT_STORAGE_S3_SECRET_ACCESS_KEY: "[admin 계정 Password]"
  secrets:
    ## container로 올리는 postgresql 접근 비밀번호
    TFE_DATABASE_PASSWORD: "[postgresql 접근 비밀번호]"

    ## Terraform FDO Licence
    TFE_LICENSE: "[Terraform FDO Licence]"

    ## terraform FDO vault 암호, backup & restore 시 필요함
    TFE_ENCRYPTION_PASSWORD: "[TFE_ENCRYPTION_PASSWORD]"
